% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/make_QC.R
\name{make_QC}
\alias{make_QC}
\title{Derive a quality code from provided information}
\usage{
make_QC(input, coordinates = NULL, attributes = NULL, ..., sep = "")
}
\arguments{
\item{input}{\code{\link{data.frame}}\cr tidy table that contains all input
information, this may be both the information to evaluate, but also
additional columns carrying information that shall just be passed through
the function.}

\item{coordinates}{\code{\link[=character]{character(2)}}\cr name of x and y coordinates
in the input table.}

\item{attributes}{\code{\link[=character]{character(.)}}\cr names of the attributes to
check.}

\item{...}{additional tests to check deviations from the expected value;
combination of the names of attributes and a function or the subset of
allowed values of that attribute, see details.}

\item{sep}{Separator to use between values.}
}
\description{
Take an input table and a list of columns to combine into a code of quality
information. The code will contain the value 1 in case the fail-criteria are
triggered.
}
\details{
In case no additional check is specified for an attribute, merely
the availability of any value is tested. In case there is an additional
test, the outcome of that test is pasted right after the outcome of the
availability test. In the below example 'year' is tested for availability
and for whether values are NA after converting to integers (indicating
false values) and thus occupy the two values at positions 3 and 4 in the
resulting QC. 'commodity' also has an additional test and thus occupies the
positions 5 and 6. In contrast 'landuse' will only be tested for
availability and thus only occupies position 7.

Coordinates are by default tested for availability and for plausibility
(see \code{\link{testCoords}}).
}
\examples{
\dontrun{
library(dplyr)

# make an example dataset
input <- tibble(x = sample(seq(23.3, 28.1, 0.1), 10),
                y = sample(seq(57.5, 59.6, 0.1), 10),
                year = rep(2021, 10),
                commodity = rep(c("soybean", "maize"), 5),
                landuse = sample(c("crop", "grazing", "forest"), size = 10, replace = TRUE),
                some_other = rnorm(10))
input$x[5] <- 259
input$y[9] <- NA_real_
input$year[c(2:3)] <- c(NA, "2021r")
input$commodity[c(3, 5)] <- c(NA_character_, "dog")


# derive valid values for commodities
validComm <- ontology \%>\%
  filter(class_from == "commodity") \%>\%
  distinct(term_from) \%>\%
  pull(term_from)

# specify the quality checks
input \%>\%
  make_QC(coordinates = c("x", "y"),
          attributes = c("year", "commodity", "landuse", "some_other"),
          year = .bit(fun = function(x) is.na(as.integer(x)), flags = 2),
          commodity = .bit(fun = function(x) !x \%in\% validComm, flags = 2),
          some_other = .bit(fun = function(x) ifelse(x > 0.5, 0, ifelse(x > 0, 1, 2)),
                            flags = 3),
          sep = "_")
}

}
